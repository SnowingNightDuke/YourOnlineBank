<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/jbossbuzz" /><feedburner:info uri="jbossbuzz" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><entry><title type="html">Infinispan Operator 2.2.0.Final</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/cJ2ua3v7aQc/infinispan-operator-2-2-final" /><author><name>Ryan Emerson</name></author><id>https://infinispan.org/blog/2021/10/27/infinispan-operator-2-2-final</id><updated>2021-10-27T12:00:00Z</updated><content type="html">We’re pleased to announce for Kubernetes and Red Hat OpenShift. This is the first Operator release based on Infinispan 13. Release highlights: * Custom server configuration. Add custom configuration for Infinispan Server using ConfigMap objects. * Configurable number of relay nodes for cross-site replication. Relay nodes send and receive replication requests from backup locations. You can now increase the number of relay nodes with the sites.local.maxRelayNodes field to achieve a better distribution of cross-site replication requests. * TLS security for cross-site replication traffic. You can now encrypt cross-site connections between Infinispan clusters with TLS by adding keystore secrets and configuring the sites.local.encryption field. * Operator SDK upgraded to v1.3.2&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/cJ2ua3v7aQc" height="1" width="1" alt=""/&gt;</content><dc:creator>Ryan Emerson</dc:creator><feedburner:origLink>https://infinispan.org/blog/2021/10/27/infinispan-operator-2-2-final</feedburner:origLink></entry><entry><title>A compiler option, a hidden visibility, and a weak symbol walk into a bar</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/CWaxrPz8bYg/compiler-option-hidden-visibility-and-weak-symbol-walk-bar" /><author><name>Serge Guelton</name></author><id>d1cfaebe-31ed-4e63-add8-743f9a855e39</id><updated>2021-10-27T07:00:00Z</updated><published>2021-10-27T07:00:00Z</published><summary type="html">&lt;p&gt;The &lt;a href="https://llvm.org/"&gt;LLVM&lt;/a&gt; packaging team recently ran into a &lt;a href="https://developers.redhat.com/products/gcc-clang-llvm-go-rust/overview"&gt;compiler&lt;/a&gt; problem. A build of the LLVM package with &lt;a href="https://clang.llvm.org/"&gt;Clang&lt;/a&gt;, with link-time optimization activated, failed validation. This article steps through how we explored, identified, and ultimately fixed the problem.&lt;/p&gt; &lt;h2&gt;The LLVM package build&lt;/h2&gt; &lt;p&gt;The build on the &lt;a href="https://fedoraproject.org/wiki/Releases/Rawhide"&gt;Fedora Rawhide version&lt;/a&gt; should be an easy task at the packaging level:&lt;/p&gt; &lt;pre&gt;&lt;code class="diff"&gt;diff --git a/llvm.spec b/llvm.spec (...) @@ -1,3 +1,5 @@ +%global toolchain clang (...) +BuildRequires: clang &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now, let's introduce the characters in the mystery to follow.&lt;/p&gt; &lt;h2&gt;Disabling runtime type information&lt;/h2&gt; &lt;p&gt;By default, LLVM compiles with the &lt;code&gt;-fno-rtti&lt;/code&gt; option, which disables runtime type information. According to the LLVM coding standard, the compiler disables the information to &lt;a href="https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions"&gt;reduce code and executable size&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Yet, sometimes, a type must be associated with a unique identifier. One example involves &lt;code&gt;llvm::Any&lt;/code&gt;, the LLVM version of &lt;code&gt;std::any&lt;/code&gt;. A typical implementation of &lt;code&gt;std::any&lt;/code&gt; involves &lt;code&gt;typeid&lt;/code&gt;, as showcased by &lt;a href="https://github.com/llvm/llvm-project/blob/6adbc83ee9e46b476e0f75d5671c3a21f675a936/libcxx/include/any#L293"&gt;the &lt;code&gt;libcxx&lt;/code&gt; version&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;typeid&lt;/code&gt; operator cannot be used with the &lt;code&gt;-fno-rtti&lt;/code&gt; option, so we had to find an alternative. The current implementation of &lt;code&gt;llvm::Any&lt;/code&gt; and &lt;code&gt;std::any&lt;/code&gt; can be mocked by the following snippet, mapping &lt;code&gt;&amp;TypeId&lt;MyType&gt;::Id&lt;/code&gt; to a unique identifier:&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;template &lt;typename T&gt; struct TypeId { static const char Id; }; &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Hidden visibility&lt;/h2&gt; &lt;p&gt;Parts of LLVM are compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt;. This option forces the default visibility of all symbols to be &lt;code&gt;hidden&lt;/code&gt;, which prevents them from being visible across library boundaries. Hiding symbols offers better control over exported symbols in a shared library.&lt;/p&gt; &lt;p&gt;What happens when the &lt;code&gt;TypeId&lt;/code&gt; construct from the previous section is combined with hidden visibility? Let's compile two shared libraries out of the same code:&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;template &lt;typename T&gt; struct TypeId { static const char Id; }; template &lt;typename T&gt; const char TypeId&lt;T&gt;::Id = 0; #ifdef FOO const char* foo() { return &amp;TypeId&lt;int&gt;::Id; } #else const char* bar() { return &amp;TypeId&lt;int&gt;::Id; } #endif &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We compile two binaries, one with &lt;code&gt;FOO&lt;/code&gt; defined and one without, to carry out the different &lt;code&gt;#ifdef&lt;/code&gt; paths:&lt;/p&gt; &lt;pre&gt;&lt;code class="sh"&gt;&gt; clang++ -DFOO foo.cpp -shared -o libfoo.so &gt; clang++ foo.cpp -shared -o libbar.so &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Without hidden visibility, both libraries place our &lt;code&gt;Id&lt;/code&gt; at the same address:&lt;/p&gt; &lt;pre&gt;&lt;code class="sh"&gt;&gt; llvm-nm -C libfoo.so (...) 0000000000000679 V TypeId&lt;int&gt;::Id &gt; llvm-nm -C libbar.so (...) 0000000000000679 V TypeId&lt;int&gt;::Id &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;V&lt;/code&gt; in the output indicates that the symbol is a weak object, which means that only one of the items will be chosen by the linker. Therefore, we keep unicity of the symbol and its address across compilation units.&lt;/p&gt; &lt;p&gt;But when compiled with &lt;code&gt;-fvisibility-hidden&lt;/code&gt;, the symbols no longer are weak:&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;&gt; clang++ -fvisibility=hidden foo.cpp -shared -o libbar.so &gt; llvm-nm -C libfoo.so (...) 0000000000000629 r TypeId&lt;int&gt;::Id &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;r&lt;/code&gt; next to the address means that the symbol is in a read-only data section. The symbol is not dynamically linked (as we can confirm from the output of &lt;code&gt;llvm-nm -D&lt;/code&gt;), so it gets different addresses in &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. In short, unicity is not preserved.&lt;/p&gt; &lt;h2&gt;Fine-grained control over symbol visibility&lt;/h2&gt; &lt;p&gt;A straightforward fix for the incompatibility we've uncovered is to explicitly state that &lt;code&gt;TypeId::Id&lt;/code&gt; must always have the default visibility. We can make this change as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;template &lt;typename T&gt; struct __attribute__((visibility("default"))) TypeId { static const char Id; }; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Let's check that the fix works:&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;&gt; clang++ -fvisibility=hidden foo.cpp -shared -o libbar.so &gt; llvm-nm -C libfoo.so (...) 0000000000000659 V TypeId&lt;int&gt;::Id &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;V&lt;/code&gt; for a weak symbol has returned, but that's not the end of the story.&lt;/p&gt; &lt;p&gt;Instead of parameterizing &lt;code&gt;TypeId&lt;/code&gt; by &lt;code&gt;int&lt;/code&gt;, let's parameterize it by a &lt;code&gt;HiddenType&lt;/code&gt; class declared with hidden visibility:&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;struct HiddenType {}; template &lt;typename T&gt; struct __attribute__((visibility("default"))) TypeId { static const char Id; }; template &lt;typename T&gt; const char TypeId&lt;T&gt;::Id = 0; const char* foo() { return &amp;TypeId&lt;HiddenType&gt;::Id; } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;When compiling this code with &lt;code&gt;-fvisibility-hidden&lt;/code&gt;, where does &lt;code&gt;TypeId&lt;HiddenType&gt;::Id&lt;/code&gt; end up?&lt;/p&gt; &lt;pre&gt;&lt;code class="cplusplus"&gt;&gt; clang++ -fvisibility=hidden foo.cpp -shared -o libbar.so &gt; llvm-nm -CD libbar.so | grep -c TypeId&lt;HiddenType&gt;::Id 0 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Fascinating! This exercise shows that a template function with &lt;em&gt;default&lt;/em&gt; visibility, instantiated with a type of &lt;em&gt;hidden&lt;/em&gt; visibility, ends up with &lt;em&gt;hidden&lt;/em&gt; visibility. Indeed, flagging &lt;code&gt;HiddenType&lt;/code&gt; with &lt;code&gt;__attribute__((visibility("default")))&lt;/code&gt; restores the expected behavior.&lt;/p&gt; &lt;h2&gt;Where theory meets LLVM&lt;/h2&gt; &lt;p&gt;Once we isolated the behavior described in the preceding section, we could easily provide the relevant patches in LLVM:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://reviews.llvm.org/D101972"&gt;Force visibility of &lt;code&gt;llvm::Any&lt;/code&gt; to external&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://reviews.llvm.org/D108943"&gt;Fine grain control over some symbol visibility&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://reviews.llvm.org/D109252"&gt;Add extra check for &lt;code&gt;llvm::Any::TypeId&lt;/code&gt; visibility&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;These patches fix the build issue mentioned at the beginning of the article and ensure that it won't reproduce, which is the kind of outcome programmers always look for.&lt;/p&gt; &lt;h2&gt;Acknowledgments&lt;/h2&gt; &lt;p&gt;The author would like to thank Béatrice Creusillet, Adrien Guinet, and the editorial team for their help on this article.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2021/10/27/compiler-option-hidden-visibility-and-weak-symbol-walk-bar" title="A compiler option, a hidden visibility, and a weak symbol walk into a bar"&gt;A compiler option, a hidden visibility, and a weak symbol walk into a bar&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/CWaxrPz8bYg" height="1" width="1" alt=""/&gt;</summary><dc:creator>Serge Guelton</dc:creator><dc:date>2021-10-27T07:00:00Z</dc:date><feedburner:origLink>https://developers.redhat.com/articles/2021/10/27/compiler-option-hidden-visibility-and-weak-symbol-walk-bar</feedburner:origLink></entry><entry><title>Quarkus 2.4.0.Final released - Hibernate Reactive 1.0.0, Kafka Streams DevUI, Multi module continuous testing, AWT image resize via new AWT extension and much more</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/MNE00QjR5gQ/" /><author><name>Alexey Loubyansky (https://twitter.com/aloubyansky)</name></author><id>https://quarkus.io/blog/quarkus-2-4-0-final-released/</id><updated>2021-10-27T00:00:00Z</updated><published>2021-10-27T00:00:00Z</published><summary type="html">Today, we release Quarkus 2.4.0.Final which includes a lot of refinements and improvements and some new features: Hibernate Reactive 1.0.0.Final Introducing Kafka Streams DevUI Support continuous testing for multi module projects Support AWT image resize via new AWT extension Migration Guide To migrate from 2.3, please refer to our migration...&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/MNE00QjR5gQ" height="1" width="1" alt=""/&gt;</summary><dc:creator>Alexey Loubyansky (https://twitter.com/aloubyansky)</dc:creator><dc:date>2021-10-27T00:00:00Z</dc:date><feedburner:origLink>
                https://quarkus.io/blog/quarkus-2-4-0-final-released/
            </feedburner:origLink></entry><entry><title type="html">Counterfactuals; getting the right answer</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/aspIGNLHIXg/counterfactuals-getting-the-right-answer.html" /><author><name>Roberto Emanuel</name></author><id>https://blog.kie.org/2021/10/counterfactuals-getting-the-right-answer.html</id><updated>2021-10-26T13:54:07Z</updated><content type="html">Sometimes the result of an automated decision may be neither desired or that which was required. What if there was a tool to find a way to overturn those decisions, maybe changing some of the figures that were provided to the system, and achieve a different outcome? That’s what we’ve been working on lately within the Trusty AI initiative. We added a new experimental feature to the Audit Investigation console called Counterfactual Analysis. Counterfactuals allow for the outcome of a decision to be set and a range of viable inputs to be searched over until the outcome is achieved. Let’s see how it works in detail with a practical example. GETTING AN APPROVAL FOR A DENIED LOAN We will consider a model responsible to approve or deny mortgage applications. The model produces two outputs, specifically Mortgage Approval (obviously) and a Risk Score associated to the loan request. We have submitted a request to the model, so we go to the Audit investigation dashboard and we open the execution detail to discover that the mortgage request was denied. Let’s open the Counterfactual tool using the new tab available in the navigation menu. At this point we want to specify a different outcome for the decision. To do so, we click on the "Set Up Outcomes" button. A modal window will open where we can see the original outcomes and we can change them according to our desire. We’ll set "Mortgage Approval" to True and we’ll check "Automatically adjust for counterfactual" for the Risk score. In this way the analysis will search for any risk score value that produces a Mortgage approval. Then we’ll click on "Confirm". Now we have to specify how we would like to alter the inputs in order to achieve the outcomes we’ve just chosen. In the CF table we see the list of all the inputs provided within the execution and their original value. Clicking on the checkbox at the beginning of an input row will set the input as changeable. Then clicking on its "Constraint" button we will have to set a range of values for the selected input. The system will search for values within the provided range to find solutions matching the desired outcome. So, we will enable the "TotalRequired" input and we’ll set up a range constraint from 0 to 100,000. We are basically searching what’s the amount that could be loaned given the provided salary and assets. At this point we’ve filled out all the required information to run the analysis. We’ve selected at least one outcome different from the original one (Mortgage Approval, from false to true) and we provided at least one searchable input (the requested amount). RUNNING THE ANALYSIS We are all set and we can click on "Run analysis" to start looking for solutions. The default analysis will run for one minute. At the end of it we can see that the system was able to find some results! The best solution found is showed at the far left of the results area and it’s marked with a star near its ID. We can see that the mortgage request could be approved for a "TotalRequired" sum around 18,500. At this point we could try another run by allowing other inputs to change. By clicking on "Edit Counterfactual" it’s possible to start over keeping the search options already provided. We could eventually try searching with higher values for "TotalAsset" or "MonthlySalary" for example. That’s it! Our brief introduction to the Counterfactual Analysis ends here. Keep in mind that it is still an experimental feature at the moment. It only supports a limited set of types for the outcomes and the inputs of a decision (only numbers and booleans). The Counterfactual Analysis tool will be available with the upcoming release of Kogito 1.13. You can learn more about running TrustyAI in the . FURTHER READINGS If you are interested in reading more about how counterfactuals work behind the hood you can explore the following resources: * * * The post appeared first on .&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/aspIGNLHIXg" height="1" width="1" alt=""/&gt;</content><dc:creator>Roberto Emanuel</dc:creator><feedburner:origLink>https://blog.kie.org/2021/10/counterfactuals-getting-the-right-answer.html</feedburner:origLink></entry><entry><title>Configuring Java applications to use Cryostat</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/f3NJRLPv-VA/configuring-java-applications-use-cryostat" /><author><name>Andrew Azores</name></author><id>0a0f7b21-9dcd-4bd5-a68a-1d3c2594154e</id><updated>2021-10-26T07:00:00Z</updated><published>2021-10-26T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://developers.redhat.com/blog/2021/01/25/introduction-to-containerjfr-jdk-flight-recorder-for-containers"&gt;Cryostat&lt;/a&gt; is a profiling and monitoring tool that leverages the &lt;a href="https://developers.redhat.com/blog/2020/08/25/get-started-with-jdk-flight-recorder-in-openjdk-8u"&gt;JDK Flight Recorder&lt;/a&gt; (JFR) framework already present in your HotSpot JVM applications. Cryostat provides an in-cluster collection hub for easy and secure access to your JDK Flight Recorder data from outside of the cluster.&lt;/p&gt; &lt;p&gt;This article follows our &lt;a href="https://developers.redhat.com/articles/2021/10/18/announcing-cryostat-20-jdk-flight-recorder-containers"&gt;recent announcement of Cryostat 2.0&lt;/a&gt;. It is the first of several hands-on guides to using Cryostat 2.0 in your Java applications. In this article, we'll explore how to set up and configure a &lt;a href="https://developers.redhat.com/products/quarkus/overview"&gt;Quarkus&lt;/a&gt;-based Java application to use Cryostat on &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat OpenShift&lt;/a&gt;.&lt;/p&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href="https://access.redhat.com/documentation/en-us/openjdk/11/html/release_notes_for_cryostat_2.0"&gt;The Red Hat build of Cryostat 2.0&lt;/a&gt; is now widely available in technology preview. Cryostat 2.0 introduces many new features and improvements, such as automated rules, a better API response JSON format, custom targets, concurrent target JMX connections, WebSocket push notifications, and more. The Red Hat build includes the &lt;a href="https://catalog.redhat.com/software/operators/detail/60ee049a744684587e218ef5"&gt;Cryostat Operator&lt;/a&gt; to simplify and automate Cryostat deployment on OpenShift.&lt;/p&gt; &lt;h2&gt;JMX and Cryostat&lt;/h2&gt; &lt;p&gt;The main prerequisite for using Cryostat is that your application must have Java Management Extensions (JMX) enabled and exposed. In OpenShift, exposing the JMX port means either using the Cryostat-default port number of &lt;code&gt;9091&lt;/code&gt; or naming the port &lt;code&gt;jfr-jmx&lt;/code&gt;. We will explore the procedure for exposing JMX with a Quarkus-based Java application deployed on OpenShift.&lt;/p&gt; &lt;h2&gt;Step 1: Generate the Quarkus sample application&lt;/h2&gt; &lt;p&gt;Let’s get started with the Quarkus sample application. To begin, we will visit &lt;a href="https://code.quarkus.io/"&gt;code.quarkus.io&lt;/a&gt; and generate a new application. For the purpose of this article, we will use the default &lt;code&gt;org.acme&lt;/code&gt; group and &lt;code&gt;code-with-quarkus&lt;/code&gt; &lt;code&gt;artifactId&lt;/code&gt;. Feel free to customize these as you see fit. Once you have set up your generation options, download and extract the .zip to a working directory:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ mv Downloads/code-with-quarkus.zip workspace $ cd workspace $ unzip code-with-quarkus.zip $ cd code-with-quarkus &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now we have our Quarkus application generated and ready for modification. Let’s do a quick sanity check before continuing. Once &lt;code&gt;mvnw&lt;/code&gt; has downloaded Quarkus' dependencies and built the application, you should see a message something like: “Listening on: http://localhost:8080.” Visit this URL to ensure that you see the Quarkus default welcome page.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ ./mvnw compile quarkus:dev &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Step 2: Configure the application for JMX&lt;/h2&gt; &lt;p&gt;If everything looks good so far, we can now set up the Quarkus application for JMX. Switch back to the terminal running your Quarkus application and press &lt;strong&gt;Ctrl-C&lt;/strong&gt; to stop the dev server.&lt;/p&gt; &lt;p&gt;Now that the dev server is stopped we will go ahead and edit the project's &lt;code&gt;Dockerfile.jvm&lt;/code&gt;. This file contains directives for Open Container Initiative (OCI) image builders such as Podman, Buildah, and Docker to follow when assembling the Quarkus application into an OCI image (specifically, when the application is built in JVM mode as opposed to native image mode). Once we have our JVM-mode application packaged into an OCI image then we can deploy and run that image as a container in OpenShift or Podman. Let's continue and edit the Dockerfile:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ $VISUAL src/main/docker/Dockerfile.jvm &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;There should be a line like this one:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-dockerfile"&gt; ENV JAVA_OPTIONS=”-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager” &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Let’s modify this line and add options to enable JMX:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-dockerfile"&gt; ENV JAVA_OPTIONS="-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dcom.sun.management.jmxremote.port=9096 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false" &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Here, we have enabled JMX on port 9096. For the purpose of this article, I have disabled JMX SSL and JMX authentication. In production, both should be enabled (see the &lt;a href="https://docs.oracle.com/javadb/10.10.1.2/adminguide/radminjmxenablepwdssl.html"&gt;Oracle documentation&lt;/a&gt; for more about JMX administration).&lt;/p&gt; &lt;p&gt;Now, we need to make one last change to the Dockerfile: The line &lt;code&gt;EXPOSE 8080&lt;/code&gt; should become &lt;code&gt;EXPOSE 8080 9096&lt;/code&gt;. This will add metadata to the OCI image hinting that the application within will listen on ports &lt;code&gt;8080&lt;/code&gt; and &lt;code&gt;9096&lt;/code&gt;, so that when we deploy this on OpenShift later those two ports will be automatically included in the generated Service for intra-cluster network traffic.&lt;/p&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Why we're running Quarkus in JVM mode&lt;/strong&gt;: You may have noticed that we have edited only the Dockerfile.jvm and not the other Dockerfiles, like Dockerfile.native. This is because Quarkus in native-image mode does not currently support JMX. We will need to run Quarkus in JVM mode to have access to JMX and, therefore, to be Cryostat-compatible.&lt;/p&gt; &lt;h2&gt;Step 3: Take it for a test drive (optional)&lt;/h2&gt; &lt;p&gt;This configuration will set up the sample Quarkus application to use JMX when built and run as an OCI image. If you would like to test drive JMX and JFR with Quarkus before we get to that stage, you can do the following:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ ./mvnw -Djvm.args=”-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dcom.sun.management.jmxremote.port=9096 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false” compile quarkus:dev &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This will run the &lt;code&gt;quarkus:dev&lt;/code&gt; server with JMX enabled and configured the same way we have specified in the Dockerfile.jvm. Now, open JDK Mission Control, and you should see the Quarkus application in the JVM browser panel.&lt;/p&gt; &lt;h2&gt;Step 4: Build the application into a container image&lt;/h2&gt; &lt;p&gt;Once we are satisfied with our configuration, let’s go ahead and build the application into a container image. Since we want to deploy this application to OpenShift, I will tag it with an example &lt;code&gt;quay.io&lt;/code&gt; tag, which you should replace with your own username and application name:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ ./mvnw package $ podman build -f src/main/docker/Dockerfile.jvm -t quay.io/&lt;namespace&gt;/code-with-quarkus . &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We'll do one more sanity check, and if it looks good, push it to quay.io:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ podman run -i --rm -p 8080:8080 -p 9096:9096 quay.io/&lt;namespace&gt;/code-with-quarkus $ # open http://localhost:8080 in your browser once more and ensure you see the Quarkus welcome page $ podman push quay.io/&lt;namespace&gt;/code-with-quarkus &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once that image is pushed we need to visit quay.io (for example, https://quay.io/&lt;namespace&gt;/code-with-quarkus?tab=settings) and make the image repository public. After that, we can deploy it to our OpenShift cluster:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ oc new-app quay.io/&lt;namespace&gt;/code-with-quarkus:latest $ oc edit svc code-with-quarkus $ # rename the port “9096-tcp” to “jfr-jmx”, but leave the port, targetPort, etc. the same $ oc expose --port=8080 svc code-with-quarkus $ oc status # check that the code-with-quarkus app is accessible and still displays the Quarkus welcome page &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Step 5: Install Cryostat 2.0 on OpenShift&lt;/h2&gt; &lt;p&gt;See the &lt;a href="https://developers.redhat.com/articles/2021/10/18/announcing-cryostat-20-jdk-flight-recorder-containers"&gt;Cryostat 2.0 announcement&lt;/a&gt; for how to install Cryostat in your OpenShift cluster using the Cryostat Operator. Once you have Cryostat installed and present in the same OpenShift namespace as your code-with-quarkus example application, you can verify that everything is wired up correctly:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt; $ oc get flightrecorders &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;There should be an item like &lt;code&gt;code-with-quarkus-5645dbdd47-z7pl7&lt;/code&gt;. This indicates that the Cryostat Operator is running and recognizes our Quarkus application as being Cryostat-compatible.&lt;/p&gt; &lt;p&gt;Check &lt;code&gt;oc status&lt;/code&gt; again and visit the Cryostat URL. Enter your OpenShift account token (you can retrieve it from the OpenShift console or with &lt;code&gt;oc whoami -t&lt;/code&gt;), then select the &lt;code&gt;code-with-quarkus application&lt;/code&gt; and go to the &lt;strong&gt;Events&lt;/strong&gt; view. If you see a list of event templates loaded, then your Cryostat and Quarkus instances are communicating successfully!&lt;/p&gt; &lt;h2&gt;Conclusion&lt;/h2&gt; &lt;p&gt;This article was the first of several that will provide hands-on introductions to using Cryostat with your Java applications. Look for the next article in this series, which introduces you to defining custom targets for Cryostat.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2021/10/26/configuring-java-applications-use-cryostat" title="Configuring Java applications to use Cryostat"&gt;Configuring Java applications to use Cryostat&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/f3NJRLPv-VA" height="1" width="1" alt=""/&gt;</summary><dc:creator>Andrew Azores</dc:creator><dc:date>2021-10-26T07:00:00Z</dc:date><feedburner:origLink>https://developers.redhat.com/articles/2021/10/26/configuring-java-applications-use-cryostat</feedburner:origLink></entry><entry><title type="html">Kogito 1.12.0 released!</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/jCSVrBT_zuY/kogito-1-12-0-released.html" /><author><name>Cristiano Nicolai</name></author><id>https://blog.kie.org/2021/10/kogito-1-12-0-released.html</id><updated>2021-10-26T00:48:26Z</updated><content type="html">We are glad to announce that the Kogito 1.12.0 release is now available! This goes hand in hand with, , Operator, and CLI 1.12.0 release. From a feature point of view, we included a series of new features and bug fixes, including: * Improvement in protobuf persistence generation: support for fields inherited from parent classes and ability to disable protobuf generation * Ability to create custom REST endpoints using Kogito incubator API * Data Index service new Gateway API methods for handling process instances, human tasks and jobs * JDBC persistence addon now has been tested with Oracle and should work with any ANSI SQL compatible storage (thanks for the contribution) * Kogito event driven DRL: ability to trigger DRL evaluation via CloudEvent Kafka messages * Kogito event driven PMML: ability to trigger PMML evaluation via CloudEvent Kafka messages * Support for FEEL expression in BPMN Gateways * Added BPMN validations around data input and and output types where they should match the expected type from the target/source process variable. BREAKING CHANGES * Operator OLM installation, today we support OwnNamespace and SingleNamespace install modes, however, when using OLM, AllNamesapces mode will be used.  For more details head to the complete. All artifacts are available now: * Kogito runtime artifacts are available on Maven Central. * Kogito examples can be found. * Kogito images are available on. * Kogito operator is available in the in OpenShift and Kubernetes. * Kogito tooling 0.13.0 artifacts are available at the. A detailed changelog for 1.12.0 can be found in. New to Kogito? Check out our website. Click the "Get Started" button. The post appeared first on .&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/jCSVrBT_zuY" height="1" width="1" alt=""/&gt;</content><dc:creator>Cristiano Nicolai</dc:creator><feedburner:origLink>https://blog.kie.org/2021/10/kogito-1-12-0-released.html</feedburner:origLink></entry><entry><title type="html">What's new in Vert.x 4.2</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/URg6OKCDNRc/whats-new-in-vert-x-4-2" /><author><name>Julien Viet</name></author><id>https://vertx.io/blog/whats-new-in-vert-x-4-2</id><updated>2021-10-26T00:00:00Z</updated><content type="html">See an overview of all new and exciting features in Vert.x 4.2, including Java 17 supports, Vert.x Oracle Client and more.&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/URg6OKCDNRc" height="1" width="1" alt=""/&gt;</content><dc:creator>Julien Viet</dc:creator><feedburner:origLink>https://vertx.io/blog/whats-new-in-vert-x-4-2</feedburner:origLink></entry><entry><title type="html">Secure WildFly applications with OpenID Connect</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/AeRoyUibUok/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/jbossas/jboss-security/secure-wildfly-applications-with-openid-connect/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=secure-wildfly-applications-with-openid-connect</id><updated>2021-10-25T10:41:56Z</updated><content type="html">WildFly 25 enables you to secure deployments using OpenID Connect (OIDC) without installing a Keycloak client adapter. This tutorial will show a proof of concept example of it. OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol which allows Clients to verify the identity of the End-User based on the ... The post appeared first on .&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/AeRoyUibUok" height="1" width="1" alt=""/&gt;</content><dc:creator>F.Marchioni</dc:creator><feedburner:origLink>http://www.mastertheboss.com/jbossas/jboss-security/secure-wildfly-applications-with-openid-connect/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=secure-wildfly-applications-with-openid-connect</feedburner:origLink></entry><entry><title>Quarkus Tools for IntelliJ 1.8.0 released!</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/Ox1gRJms-0U/" /><author><name>Jeff Maury (https://twitter.com/jeffmaury)</name></author><id>https://quarkus.io/blog/intellij-quarkus-tools-1.8.0/</id><updated>2021-10-25T00:00:00Z</updated><published>2021-10-25T00:00:00Z</published><summary type="html">We are very pleased to announce the 1.8.0 release of Quarkus Tools for IntelliJ. This release adds support for CodeLens for REST endpoints and enhances MicroProfile Fault Tolerance and Metrics supports. Codelens When editing a resource class while the current Quarkus application is running in development mode (./mvnw compile quarkus:dev...&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/Ox1gRJms-0U" height="1" width="1" alt=""/&gt;</summary><dc:creator>Jeff Maury (https://twitter.com/jeffmaury)</dc:creator><dc:date>2021-10-25T00:00:00Z</dc:date><feedburner:origLink>
                https://quarkus.io/blog/intellij-quarkus-tools-1.8.0/
            </feedburner:origLink></entry><entry><title type="html">Developing applications with IntelliJ Idea and WildFly</title><link rel="alternate" href="http://feedproxy.google.com/~r/jbossbuzz/~3/8JWt3amLBzI/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/eclipse/intellij-idea/developing-applications-with-intellij-idea-and-wildfly/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=developing-applications-with-intellij-idea-and-wildfly</id><updated>2021-10-22T12:47:04Z</updated><content type="html">IntelliJ IDEA is a popular choice for developing Enterprise applications featuring automatic Maven and Maven integration. In this tutorial we will learn how to integrate IntelliJ with WildFly or JBoss EAP. IntelliJ IDEA assumes that all development, debugging, and testing is done on your computer and then the code is deployed to a production environment. Let’s see ... The post appeared first on .&lt;img src="http://feeds.feedburner.com/~r/jbossbuzz/~4/8JWt3amLBzI" height="1" width="1" alt=""/&gt;</content><dc:creator>F.Marchioni</dc:creator><feedburner:origLink>http://www.mastertheboss.com/eclipse/intellij-idea/developing-applications-with-intellij-idea-and-wildfly/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=developing-applications-with-intellij-idea-and-wildfly</feedburner:origLink></entry></feed>
